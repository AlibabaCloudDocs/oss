# HTTP 409 status code

This topic describes the types of error messages returned with HTTP status code 409, and the common causes and solutions to these errors.

## BucketAlreadyExists

-   Error message: The requested bucket name is not available.

    Cause: The specified bucket already exists or is owned by another user.

    Solution: Specify another name for the bucket. For more information about how to create a bucket, see [Create buckets](/intl.en-US/Quick Start/OSS console/Create buckets.md).

-   Error message: Bucket already exists can't modify location.

    Cause: The region of an existing bucket cannot be changed.

    Solution: Recreate the bucket in a different region.

-   Error message: Cannot modify existing bucket's storage class.or Bucket already exists can't modify storage type.

    Cause: The storage class of an existing bucket cannot be changed.

    Solution: Recreate the bucket and specify the storage class of the bucket.

-   Error message: Bucket already exists CAN'T modify data redundancy type.

    Cause: The disaster recovery type of an existing bucket cannot be changed.

    Solution: Recreate the bucket and specify the disaster recovery type of the bucket.


## BucketNotEmpty

-   Error message: The bucket you tried to delete is not empty.
-   Cause: The bucketyou want to delete contains objects, parts generated by incomplete multipart upload tasks, or LiveChannels.
-   Solution:
    -   Delete all objects in the bucket. Then, delete the bucket.

        For more information about how to delete objects, see [Delete objects](/intl.en-US/Developer Guide/Objects/Manage files/Delete objects.md). If your buckets store a large number of objects, we recommend that you configure lifecycle rules to delete objects in batches. For more information, see [Configure lifecycle rules](/intl.en-US/Console User Guide/Manage buckets/Basic settings/Configure lifecycle rules.md).

    -   Delete the parts generated by multipart upload or resumable upload tasks in the bucket and then delete the bucket.

        For more information about how to delete parts in a bucket, see [Manage parts](/intl.en-US/Console User Guide/Upload, download, and manage objects/Manage parts.md).

    -   Delete all LiveChannels in the bucket and delete the bucket.

        For more information about how to delete LiveChannels, see [DeleteLiveChannel](/intl.en-US/API Reference/LiveChannel-related operations/DeleteLiveChannel.md). For more information about LiveChannels, see [RTMP-based stream ingest](/intl.en-US/Developer Guide/Objects/Upload files/RTMP-based stream ingest.md).


## PositionNotEqualToLength

-   Error message: Position is not equal to file length.
-   Cause:
    -   The value of position in the request does not match the current object length.
    -   The request is successful in the following scenarios: 1. The value of position is 0 and the length of an append object that has the same name is 0. 2. The value of position is 0 and the append object that has the same name does not exist. In all other cases, this error is returned because the position and the length of the object do not match.
-   Solution: Obtain the value of the position for the next operation from the response header `x-oss-next-append-position`, and then send the next request. Multiple requests may be sent concurrently. Therefore, even if you set the position header in a request to the value of `x-oss-next-append-position` in the response to the previous request, the request may still fail because the value is not updated immediately.`` For more information, see [AppendObject](/intl.en-US/API Reference/Object operations/Basic operations/AppendObject.md).

## FileAlreadyExists

-   Error message: The object you specified already exists and can not be overwritten.
-   Cause: The specified object already exists and cannot be overwritten because the request contains the `x-oss-forbid-overwrite=true` header.
-   Solution:

    Use the following methods to overwrite an existing object that has the same name in simple upload, multipart upload, and object copy:

    -   Do not include the x-oss-forbid-overwrite header in the request or set this header to false.
    -   Enable versioning for the bucket in which the object that you want to overwrite is stored. The overwritten object is stored as a previous version. You can recover to a previous version at any time.

## LiveChannelDisabled

-   Error message: Live channel is disabled by owner.
-   Cause: Streams cannot be ingested to a disabled LiveChannel. If you are ingesting a stream to a LiveChannel whose state is disabled, your client is disconnected from the LiveChannel after about 10 seconds.
-   Solution: Enable the LiveChannel and then ingest streams to the LiveChannel. For more information, see [PutLiveChannelStatus](/intl.en-US/API Reference/LiveChannel-related operations/PutLiveChannelStatus.md).

## ChannelStillLive

-   Error message: Live channel couldn't be updated or deleted when channel is live.
-   Cause: You have attempted to update or delete a LiveChannel that is in the Live state, which indicates that the client is ingesting streams to the connected ingest URL. A LiveChannel in this state cannot be updated or deleted.
-   Solution: Update or delete the LiveChannel after the client stops ingesting streams.

## FileImmutable

-   Error message: The object you specified is immutable.
-   Cause: You have attempted to delete or modify an object protected by a retention policy.
-   Solution: Delete or modify the object after the retention policy expires. During the retention period of the retention policy, the objects in the bucket cannot be deleted or modified. You can call [GetBucketWorm](/intl.en-US/API Reference/Bucket operations/Retention policy/GetBucketWorm.md) to query the retention period of a retention policy.

## RestoreAlreadyInProgress

-   Error message: The restore operation is in progress.
-   Cause: A RestoreObject request is submitted and the object is being restored on the OSS server.
-   Solution: Do not repeatedly send RestoreObject requests.

## KeyDisabled

-   Error message: The request was rejected because the key state is Disabled.
-   Cause: The specified CMK is disabled.
-   Solution: Call the [EnableKey](/intl.en-US/API Reference/Key/EnableKey.md) operation to enable the CMK for encryption and decryption.

## KeyPendingDeletion

-   Error message: The request was rejected because the key state is PendingDeletion.
-   Cause: The specified CMK is in the PendingDeletion state.
-   Solution: Use another CMK for encryption and decryption. A CMK that is in the PendingDeletion state cannot be used to encrypt data, decrypt data, or generate data keys. After a CMK is deleted, it cannot be recovered. Data encrypted and data keys generated by using the CMK cannot be decrypted. Therefore, KMS allows you only to schedule key deletion tasks to prevent you from deleting CMKs by mistake. For more information, see [ScheduleKeyDeletion](/intl.en-US/API Reference/Key/ScheduleKeyDeletion.md). You can call the [DisableKey](/intl.en-US/API Reference/Key/DisableKey.md) operation to disable a CMK instead of deleting the CMK.

## KeyPendingImport

-   Error message: The request was rejected because the key state is PendingImport.
-   Cause: The specified CMK is in the PendingImport state.
-   Solution: Call the ImportKeyMaterial operation to import the key material. A CMK that is in the PendingImport state cannot be used to encrypt data, decrypt data, or generate data keys. For more information, see [ImportKeyMaterial](/intl.en-US/API Reference/Key/ImportKeyMaterial.md).

## WORMConfigurationAlreadyExists

-   Error message: The WORM Configuration already exists.
-   Cause: A retention policy has already been configured for the bucket.
-   Solution: Delete the existing retention policy if it is not locked and configure a new retention policy for the bucket. Only one retention policy can be configured for a bucket. For more information, see [Retention policy](/intl.en-US/Developer Guide/Data security/Retention policy.md).

## InventoryConfigurationAlreadyExists

-   Error message: The Inventory Configuration already exists.
-   Cause: You have configured an inventory whose name is the same as an existing inventory.
-   Solution: Specify an inventory whose name is globally unique in the bucket. You can call the [GetBucketInventory](/intl.en-US/API Reference/Bucket operations/Inventory/GetBucketInventory.md) operation to query the inventories configured for a bucket.

